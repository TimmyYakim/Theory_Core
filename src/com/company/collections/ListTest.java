package com.company.collections;

import java.util.*;

public class ListTest {

    public static void main(String[] args) {
        testArrayList();
        System.out.println("======================");
        testLinkedList();
    }


    /**
     * Динамически расширяемый массив. Основан на обычном массиве.
     * При расширении (oldCapacity * 3) / 2 + 1 копируется предыдущий массив при помощи нативного System.arraycopy().
     * По этой причине большая скорость.
     *
     * — Быстрый доступ к элементам по индексу за время O(1);
     * — Доступ к элементам по значению за линейное время O(n);
     * — Медленный, когда вставляются и удаляются элементы из «середины» списка O(n);
     * — Позволяет хранить любые значения в том числе и null;
     * — Не синхронизирован.
     *
     * Следует применять при частом обращение к элементам по индексу (за константное время O(1)).
     * Избегать при частом удалении/добавлении элементов в середину коллекции.
     */
    private static void testArrayList() {
        List<Integer> digits = Arrays.asList(0, 1, 2, 3, 5); // не поддерживает изменения размера
        List<Integer> someDigits = new ArrayList<>();

        someDigits.add(6);
        someDigits.add(7);
//        java.lang.UnsupportedOperationException
//        Arrays.asList returns a fixed sized list backed by an array, and you can't add elements to it.
//        digits.addAll(someDigits);
        // При добавлении нескольких элементов в целях производительности лучше использовать addAll()
        List<Integer> allDigits = new ArrayList<>(digits);
        allDigits.addAll(someDigits); // [0, 1, 2, 3, 5, 6, 7]
        // альтернатива предыдущему, но:
        // - работает быстрее
        // - принимает на вход любую коллекцию
        // - не возникает проблем изменения массива
        Collections.addAll(allDigits, 6, 7);
        allDigits.add(4, 4); // [1, 2, 3, 4, 5, 6, 7]

//        при удалении элементов текущая величина capacity не уменьшается,
//        что может привести к своеобразным утечкам памяти.
//        Поэтому не стоит пренебрегать методом trimToSize().
        allDigits.remove(6); // [0, 1, 2, 3, 4, 5, 7]
        allDigits.remove(allDigits.size()-1); // [0, 1, 2, 3, 4, 5]
        allDigits.removeAll(Arrays.asList(4, 5)); // [0, 1, 2, 3]


        allDigits.indexOf(2); // 2


//        allDigits.isEmpty(); // false
//        allDigits.contains(6); // true
//        allDigits.containsAll(Arrays.asList(6, 7, 8)); // false
//        allDigits.get(5); // 5


        System.out.println(allDigits.indexOf(2));
    }


    /**
     * LinkedList — класс, реализующий два интерфейса — List и Deque. Это обеспечивает возможность создания
     * двунаправленной очереди из любых (в том числе и null) элементо
     *
     * Позволяет хранить любые данные, включая null. Особенностью реализации данной коллекции является то, что в
     * её основе лежит двунаправленный связный список (каждый элемент имеет ссылку на предыдущий и следующий).
     * Благодаря этому, добавление и удаление из середины, доступ по индексу, значению происходит за линейное время
     * O(n), а из начала и конца за константное O(1). Так же, ввиду реализации, данную коллекцию можно использовать
     * как стек или очередь. Для этого в ней реализованы соответствующие методы. На Хабре также есть статья с подробным
     * анализом и описанием этой коллекции.
     *
     * — Медленный доступ к элементам по индексу за время O(n);
     * — Доступ к элементам по значению за линейное время O(n);
     * — Быстрый, когда вставляются и удаляются элементы из «середины» списка O(1); при условии, что известна ссылка на этот элемент
     * — Позволяет хранить любые значения в том числе и null;
     * — Не синхронизирован.
     */
    private static void testLinkedList() {
        List<Integer> numbers = new LinkedList<>();

    }


    /**
     * реализация динамического массива объектов. Позволяет хранить любые данные, включая null в качестве элемента.
     * Vector появился в JDK версии Java 1.0, но как и Hashtable, эту коллекцию не рекомендуется использовать,
     * если не требуется достижения потокобезопасности. Потому как в Vector, в отличии от других реализаций List,
     * все операции с данными являются синхронизированными. В качестве альтернативы часто применяется аналог — ArrayList.
     */
    private static void testVector() {

    }


}
